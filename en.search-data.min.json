[{"id":0,"href":"/dit8/robotics/assessments/followTheLine/","title":"Follow the line","parent":"Assessment tasks","content":"In teams (of up to 2), design algorithms using flowcharts to create an automated, driverless vehicle that can stop at line and follow a line. Explore how an automated vehicle might be guided along a road or track and how line detection could be used to save lives. Design ways to improve driving safety by helping to prevent drivers from falling asleep and causing an accident.\nTask Description    You will need to complete all the following sections as part of your collaborative presentation:\n  Drive and stop at a line\n Design a flowchart for the automated vehicle to stop at a line. Working code with comments Validation video    Following the line\n Design a flowchart for the automated, driverless vehicle to follow a line. Working code with comments Validation video Explain how an automated vehicle might be guided along a road or track. Once the wheeled robot is following the line, can it be improved to behave more like a car (i.e., move in a straight line rather than a wiggle)?    Line Detection\n To simulate what could happen if a driver falls asleep while driving, your robot could sound an alarm signal when it crosses the line. Program your robot to perform this function. Add you working code with comments. What can happen if a driver falls asleep while driving? How can we detect when a driver is falling asleep? How could you improve your program?    Extension\nSimulate a vehicle’s behaviour at traffic lights by having their wheeled robot respond to a series of green and red signals. Placing their code inside a loop allows for the possibility of multiple “traffic lights” along a track. Use the technic beams available in the EV3 core set to simulate green and red lights. Place the beams on the table so the Color Sensor can detect them while rolling over them.\n  To Be Successful     Appropriate protocols when taking a photos/videos of others. Acknowledges sources appropriately including graphics Plan and implement consistent and logical navigation Includes hyperlinks to navigate the presentation References sources appropriately Complete at least all items of first 3 parts of this task.  Learner Behaviours    This task provides the following opportunities to develop and demonstrate the Learner Behaviours:\n Driven Engages in Python coding challenges with persistence and learns from their mistakes and willingly completes the extension activities. Curious Explores and tests ideas by asking questions, researching and through trial and error when learning new skills or developing solutions Collaborators Works in teams to solve problems and create new information. Willingly shares new skills and knowledge and assists others and seeks assistance from peers. Connected Connects programming constructs and data structures to real life applications and is able to explore and discuss issues and ethical implications of their solution Flexible Thinkers Applies new knowledge and skills to solve problems and is able to adapt and recognize patterns in other solutions Disciplined Motivated learner who demonstrates initiative by following a project management process to complete a project  "},{"id":1,"href":"/dit8/gameDesign/03walkthroughs/gemCatcher/","title":"Gem Catcher","parent":"Walk-throughs","content":" First program update() Adding a gem Collision and Random Keeping Score Mouse and Events Game Over Challenges  "},{"id":2,"href":"/dit8/robotics/gettingStarted/","title":"Getting Started","parent":"Robotics","content":""},{"id":3,"href":"/dit8/gameDesign/02basics/python/","title":"Python","parent":"Learning the basics","content":"If you are new to Python, check out this interactive guide.\nIf you\u0026rsquo;re feeling you can get up to speed with:\n[Aposteriori: Introduction to Python]\nThere is also an excellent reference to key ideas, with working examples, here\n"},{"id":4,"href":"/dit8/robotics/gettingStarted/software/","title":"Software","parent":"Getting Started","content":"To control the LEGO Mindstorms robots running ev3dev, you will need to:\n  Open the Company Portal:   Find and install Visual Studio Code (NOT Visual Studio Community):   Install the EV3 MicroPython extension   "},{"id":5,"href":"/dit8/robotics/assessments/followTheLineCheat/","title":"FTL help","parent":"Assessment tasks","content":" Part 1  from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.robotics import DriveBase from pybricks.tools import wait from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor) # Initialize the EV3 Brick.  ev3 = EV3Brick() # Initialize the motors.  left_motor = Motor(Port.B) right_motor = Motor(Port.C) # Initialize the Touch Sensor.  # touch_sensor = TouchSensor(Port.S1)  # Initialize the Colour Sensor.  color_sensor = ColorSensor(Port.S3) # Initialize the ultrasonic sensor.  # ultrasonic_sensor = UltrasonicSensor(Port.S4)  # Initialize the drive base.  robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) # Write your program here. robot.drive(200, 0) while color_sensor.reflection() \u0026lt; 10: wait(10) robot.stop()   Part 2  from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.robotics import DriveBase from pybricks.tools import wait from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor) # Initialize the EV3 Brick.  ev3 = EV3Brick() # Initialize the motors.  left_motor = Motor(Port.B) right_motor = Motor(Port.C) # Initialize the Touch Sensor.  # touch_sensor = TouchSensor(Port.S1)  # Initialize the Colour Sensor.  color_sensor = ColorSensor(Port.S3) # Initialize the ultrasonic sensor.  # ultrasonic_sensor = UltrasonicSensor(Port.S4)  # Initialize the drive base.  robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) # Write your program here. robot.drive(50, 0) while True: value = color_sensor.reflection() if value \u0026gt; 30: # too bright # on line # veer left robot.drive(50, -50) elif value \u0026lt; 10: # too dark # off line # veer right robot.drive(50, 50) else: # value is okay # drive straight robot.drive(50, 0) wait(10)    "},{"id":6,"href":"/dit8/gameDesign/","title":"Game Design","parent":"8 DigiTech","content":""},{"id":7,"href":"/dit8/gameDesign/03walkthroughs/ninjaRunner/","title":"Ninja Runner","parent":"Walk-throughs","content":" Infinite Runner Background Ninja Jumping Obstacles Keeping Score Game Over Challenges and Bugs  "},{"id":8,"href":"/dit8/robotics/gettingStarted/using/","title":"Using the EV3","parent":"Getting Started","content":"Taken from pybricks.com\nTurning the EV3 Brick on and off    Turn on the EV3 Brick by pressing the dark gray center button.\nThe boot process may take several minutes. While booting, the EV3 Brick status light turns orange and blinks intermittently, and you’ll see a lot of text on the EV3 screen. The EV3 Brick is ready for use when the status light turns green.\nTo turn the EV3 Brick off, open the shutdown menu with the back button, and then select Power Off using the center button, as shown in Figure 5.\n Figure 5: Turning the EV3 Brick off   Viewing motor and sensor values    When you’re not running a program, you can view motor and sensor values using the device browser, as shown in Figure 6.\n Figure 6: Viewing motor and sensor values   Running a program without a computer    You can run previously downloaded programs directly from the EV3 Brick.\nTo do so, find the program using the file browser on the EV3 screen and press the center button key to start the program as shown in Figure 7.\n Figure 7: Starting a program using the buttons on the EV3 Brick   "},{"id":9,"href":"/dit8/robotics/gettingStarted/programs/","title":"Creating and running programs","parent":"Getting Started","content":"Taken from pybricks.com\n Now that you’ve set up your computer and EV3 Brick, you’re ready to start writing programs.\nTo make it easier to create and manage your programs, let’s first have a quick look at how MicroPython projects and programs for your EV3 robots are organized.\nPrograms are organized into project folders, as shown in Figure 8. A project folder is a directory/folder on your computer that contains the main program (main.py) and other optional scripts or files. This project folder and all of its contents will be copied to the EV3 Brick, where the main program will be run.\nThis page shows you how to create such a project and how to transfer it to the EV3 Brick.\n Figure 8: A project contains a program called main.py and optional resources like sounds or MicroPython modules.   Creating a new project    To create a new project, open the EV3 MicroPython tab and click create a new project, as shown in Figure 9. Enter a project name in the text field that appears and press Enter. When prompted, choose a location for this program and confirm by clicking choose folder.\n Figure 9: Creating a new project. This example is called getting_started, but you can choose any name.   When you create a new project, it already includes a file called main.py. To see its contents and to modify it, open it from the file browser as shown in Figure 10. This is where you’ll write your programs.\nIf you are new to MicroPython programming, we recommend that you keep the existing code in place and add your code to it.\n Figure 10: Opening the default main.py program.   Opening an existing project    To open a project you created previously, click File and click Open Folder, as shown in Figure 11. Next, navigate to your previously created project folder and click OK. You can also open your recently used projects using the Open Recent menu option.\n Figure 11: Opening a previously created project.   Connecting to the EV3 Brick with Visual Studio Code    To be able to transfer your code to the EV3 Brick, you’ll first need to connect the EV3 Brick to your computer with the mini-USB cable and configure the connection with Visual Studio Code. To do so:\n Turn the EV3 Brick on Connect the EV3 Brick to your computer with the mini-USB cable Configure the USB connection as shown in Figure 12.   Figure 12: Configuring the USB connection between the computer and the EV3 Brick   Downloading and running a program    You can press the F5 key to run the program. Alternatively, you can start it manually by going to the debug tab and clicking the green start arrow, as shown in Figure 13.\nWhen the program starts, a pop-up toolbar allows you to stop the program if necessary. You can also stop the program at any time using the back button on the EV3 Brick.\nIf your program produces any output with the print command, this is shown in the output window.\n Figure 13: Running a program   Expanding the example program    Now that you’ve run the basic code template, you can expand the program to make a motor move. First, attach a Large Motor to Port B on the EV3 Brick, as shown in Figure 14.\n Figure 14: The EV3 Brick with a Large Motor attached to port B.   Next, edit main.py to make it look like this:\n#!/usr/bin/env pybricks-micropython from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port # Create your objects here # Initialize the EV3 Brick. ev3 = EV3Brick() # Initialize a motor at port B. test_motor = Motor(Port.B) # Write your program here # Play a sound. ev3.speaker.beep() # Run the motor up to 500 degrees per second. To a target angle of 90 degrees. test_motor.run_target(500, 90) # Play another beep sound. ev3.speaker.beep(frequency=1000, duration=500) This program makes your robot beep, rotate the motor, and beep again with a higher pitched tone. Run the program to make sure that it works as expected.\nManaging files on the EV3 Brick    After you’ve downloaded a project to the EV3 Brick, you can run, delete, or back up programs stored on it using the device browser as shown in Figure 15.\n Figure 15: Using the EV3 device browser to manage files on your EV3 Brick   "},{"id":10,"href":"/dit8/gameDesign/02basics/graphics/","title":"Drawing graphics","parent":"Learning the basics","content":"To create graphics for our games we will use the Pygame Zero library. You will find the documentation on the website useful!\nThe smallest square that can be displayed on a monitor is called a pixel. This diagram shows a close-up view of a window that is 40 pixels wide and 40 pixels high. At normal size you will not see the grid lines.\nModel View Controller Fig. 4.1 Model View Controller\nWe can refer to any pixel by giving two co-ordinates, (x,y) Make sure you understand co-ordinates before moving on because everything we do in Pygame Zero will use it. (In maths this called a ‘Cartesian coordinate system’).\nLines and circles    If are using the Mu editor, Pygame Zero is built-in, but you must remember to click ‘Mode’ and select ‘Pygame Zero’ before running your program!\nIf you are using a different editor, instructions are online.\nProgram 4.1 Lines and circles\n1 2 3 4 5 6 7 8 9 10  WIDTH = 500 # What are these units? What if we change them? HEIGHT = 500 # What if we delete this line? def draw(): screen.clear() screen.draw.circle((250, 250), 50, \u0026#34;white\u0026#34;) screen.draw.filled_circle((250, 100), 50, \u0026#34;red\u0026#34;) screen.draw.line((150, 20), (150, 450), \u0026#34;purple\u0026#34;) screen.draw.line((150, 20), (350, 20), \u0026#34;purple\u0026#34;)   Exercise    Finish drawing this picture\nExercise    Draw your own picture.\nMoving rectangles    To make things move we need to add the special update() function. We don’t need to write our own loop because Pygame Zero calls this function for us in its own loop, over and over, many times per second.\nProgram 4.2 Moving rectangles\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  WIDTH = 500 HEIGHT = 500 box = Rect((20, 20), (50, 50)) def draw(): screen.clear() screen.draw.filled_rect(box, \u0026#34;red\u0026#34;) def update(): box.x = box.x + 2 if box.x \u0026gt; WIDTH: box.x = 0   Exercise    Make the box move faster.\nExercise    Make the box move in different directions.\nExercise    Make two boxes with different colours.\n1 2 3 4 5 6  import pgzrun WIDTH = 800 HEIGHT = 600 pgzrun.go() # Must be last line   Background    Now let\u0026rsquo;s add a coloured background. To do this we need to define a function called draw(), which Pygame Zero will call every time it needs to redraw the screen:\n1 2 3 4 5 6 7 8 9  import pgzrun WIDTH = 800 HEIGHT = 600 def draw(): screen.fill((128, 0, 0)) pgzrun.go() # Must be last line   Why the double brackets?\nNotice that we had to use two sets of brackets in that example to set the colour of the background. In Pygame Zero, colours are always written as a set of three numbers like this: (0, 130, 255), which in Python is called a tuple (rhyming with \u0026lsquo;couple\u0026rsquo;). A tuple is indicated with round brackets. But the function also takes a set of round brackets, so we know it is a function. So the outer set of brackets belongs to the fill() function call, and the inside set to the tuple for the colour.  Basic shapes    Let\u0026rsquo;s add a couple of basic shapes.\n1 2 3 4 5 6 7 8 9 10  import pgzrun WIDTH = 800 HEIGHT = 600 def draw(): screen.fill((128, 0, 0)) screen.draw.filled_circle((0,150), 10, (200, 100, 200)) pgzrun.go() # Must be last line   The filled_circle() command takes three bits of information, known as arguments:\n the co-ordinates of the circle\u0026rsquo;s centre (x, y) as a tuple, the radius, the colour (r, g, b) as a tuple.  "},{"id":11,"href":"/dit8/robotics/assessments/obstacleCourse/","title":"Obstacle Course","parent":"Assessment tasks","content":"In teams of two, you will design algorithms using flowcharts to create an automated, driverless vehicle that can navigate an obstacle course. You will then adapt your code to use a touch sensor and an ultrasonic sensor to complete the same course, and make comparisons between the solutions.\nThis challenge features a sequence of turns that the robot must perform in order to get to the \u0026ldquo;end\u0026rdquo; of the course. The robot must begin at the starting point and get to the goal area by completing turning and forward movement behaviours. The robot must not cross any lines.\nYou will need to complete all the following sections as part of your collaborative presentation:\n1. Traverse course with no sensors     Working code with comments Validation video  2. Wall detection with touch sensor     Design a flowchart for the automated, driverless vehicle to reach the goal using a touch sensor. Working code with comments. Validation video  3. Wall detection with ultrasonic sensor     Design a flowchart for the automated, driverless vehicle to reach the goal using an ultrasonic sensor. Working code with comments Validation video  4. Connection to our world     What differences were there between the touch and ultrasonic sensors in relation to your code and the driverless vehicle? Explain. How do modern vehicles use these two sensors?  To Be Successful     Use appropriate protocols when taking photos/videos of others. Acknowledge sources appropriately including source of graphics. Plan and implement consistent and logical navigation. Include hyperlinks to navigate the presentation. Reference sources appropriately. Complete all 3 sections of this task including questions. Work collaboratively with your partner.  Learning Behaviours    This task provides the following opportunities to develop and demonstrate the Learner Behaviours:\n Driven Engages in Python coding challenges with persistence and learns from their mistakes and willingly completes the extension activities. Curious Explores and tests ideas by asking questions, researching and through trial and error when learning new skills or developing solutions Collaborators Works in teams to solve problems and create new information. Willingly shares new skills and knowledge and assists others and seeks assistance from peers. Connected Connects programming constructs and data structures to real life applications and is able to explore and discuss issues and ethical implications of their solution Flexible Thinkers Applies new knowledge and skills to solve problems and is able to adapt and recognize patterns in other solutions Disciplined Motivated learner who demonstrates initiative by following a project management process to complete a project  "},{"id":12,"href":"/dit8/gameDesign/03walkthroughs/tankGame/","title":"Tanks","parent":"Walk-throughs","content":" Battle City 1985 Tank Moving the tank Background and Walls Randomizing the Walls Blocking Movements Tank Cannon Destroying Walls One Enemy Enemy Bullets Many Enemies Winning and Losing  "},{"id":13,"href":"/dit8/gameDesign/03walkthroughs/chaseGame/","title":"Chase game","parent":"Walk-throughs","content":"Chase game\n"},{"id":14,"href":"/dit8/robotics/assessments/robotExplorer/","title":"Robotics Explorer Project","parent":"Assessment tasks","content":"Project Brief    Within many fields such as the military, search and rescue, mining and space exploration scientists have been working on autonomous robots they may be used to carry out tasks where it is not safe for people to work. Your team\u0026rsquo;s task is to design and program an autonomous robot that can explore and navigate its way around a room by avoiding walls and other obstacles before running into them. Your robot must have the capacity to carry a small camera or mobile phone.\nFor this task, you will keep a journal of your work in a Word document, which you will submit at various points in the project.\nDefining    All projects need an introduction that tells the reader what the intended aim of the developed project will be. The problem definition explains the problem/situation and outlines the intended outcomes of the system.\nIn your journal:\n  Explain the task by describing the scenario or setting in which the problem exists. (ACTDIP027)\n  Using the table below list the Operational Features (or non-functional requirements) and the things the robot should do (or functional requirements). (ACTDIP027)\n     End-User Features (functional requirements) Operational features (non-functional requirements)     What the system should do How the system should do it   The system shall do\u0026hellip; The system shall be\u0026hellip;    Sense — Plan — Act    Before your team creates and develops a robot to achieve the goal(s) described above you need to discuss and document a SPA: SENSE — PLAN — ACT.\n SENSE The robot needs the ability to sense important things about its environment, like the presence of obstacles or navigation aids. What data does your robot need about its surroundings, and how will it gather that data? How will you validate the data collected? (ACTDIP025) PLAN The robot needs to take the sensed data and figure out how to respond appropriately to it, based on a pre-existing strategy. What is the robot\u0026rsquo;s strategy? How does your program determine the appropriate response, based on that strategy and the sensed data? Draw a flowchart of your plan. (ACTDIP029) ACT Finally, the robot must actually act to carry out the actions that the plan calls for. Will the robot design your team is planning to build allow it to sense and act out your plan, physically? What will the robot do? How will it act? (ACTDIP028)  "},{"id":15,"href":"/dit8/robotics/gettingStarted/structure/","title":"Structure of program","parent":"Getting Started","content":"For obscure, historical reasons, the first line must look exactly like this. If it doesn\u0026rsquo;t, your program won\u0026rsquo;t work at all. Accidentally adding a blank line above or a space before is a common reason your code will break.\n1  #!/usr/bin/env pybricks-micropython    The next lines are some explanatory text about what the program in this file does. It is a good habit to do this in Python, but your program will work if you don\u0026rsquo;t.\n3 4 5 6 7 8 9 10 11 12  \u0026#34;\u0026#34;\u0026#34; Example LEGO® MINDSTORMS® EV3 Robot Educator Driving Base Program ----------------------------------------------------------------- This program requires LEGO® EV3 MicroPython v2.0. Download: https://education.lego.com/en-us/support/mindstorms-ev3/python-for-ev3 Building instructions can be found at: https://education.lego.com/en-us/support/mindstorms-ev3/building-instructions#robot \u0026#34;\u0026#34;\u0026#34;    Now we need to import some extra code from the library, so that the computer knows how to drive the various parts of the EV3. Libraries are collections of useful code which are used by lots of different people, but not all the time.\n14 15 16 17 18 19  from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port, Stop from pybricks.robotics import DriveBase from pybricks.tools import wait from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor)    We need to tell the computer that we\u0026rsquo;re using an EV3 brick (which might seem a bit weird, since the computer is itself trapped in an EV3 brick, but never mind), and what we\u0026rsquo;ve connected to it.\nIf this part differs from what you\u0026rsquo;ve actually wired up, your code won\u0026rsquo;t work.\n21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  # Initialize the EV3 Brick.  ev3 = EV3Brick() # Initialize the motors.  left_motor = Motor(Port.B) right_motor = Motor(Port.C) # Initialize the Touch Sensor.  touch_sensor = TouchSensor(Port.S1) # Initialize the Colour Sensor.  color_sensor = ColorSensor(Port.S3) # Initialize the ultrasonic sensor.  ultrasonic_sensor = UltrasonicSensor(Port.S4)    DriveBase is a handy addition which allows us to drive two motors as though they were a car. We need to tell the computer:\n which motor is the left motor, which motor is the right motor, what the diameter of the wheels is, so it can work out how many times to turn the wheels to go a given distance, what the track (the distance between the wheels) is, so it can work out how far to turn the wheels to rotate the robot a given angle.  37 38  # Initialize the drive base.  robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104)   The robot is now set up and ready to go. You can add your code to the bottom of the file.\n40  # Write your program here.   Complete program    Finally, here is the complete code, to make copying it easier:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  #!/usr/bin/env pybricks-micropython  \u0026#34;\u0026#34;\u0026#34; Example LEGO® MINDSTORMS® EV3 Robot Educator Driving Base Program ----------------------------------------------------------------- This program requires LEGO® EV3 MicroPython v2.0. Download: https://education.lego.com/en-us/support/mindstorms-ev3/python-for-ev3 Building instructions can be found at: https://education.lego.com/en-us/support/mindstorms-ev3/building-instructions#robot \u0026#34;\u0026#34;\u0026#34; from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.robotics import DriveBase from pybricks.tools import wait from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor) # Initialize the EV3 Brick.  ev3 = EV3Brick() # Initialize the motors.  left_motor = Motor(Port.B) right_motor = Motor(Port.C) # Initialize the Touch Sensor.  touch_sensor = TouchSensor(Port.S1) # Initialize the Colour Sensor.  color_sensor = ColorSensor(Port.S3) # Initialize the ultrasonic sensor.  ultrasonic_sensor = UltrasonicSensor(Port.S4) # Initialize the drive base.  robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) # Write your program here.   "},{"id":16,"href":"/dit8/gameDesign/03walkthroughs/mazeGame/","title":"Maze game","parent":"Walk-throughs","content":"Maze game\nIntroduces tile maps\n"},{"id":17,"href":"/dit8/robotics/gettingStarted/movement/","title":"Movement","parent":"Getting Started","content":"adapted from PyBricks\nSet up    Having to control the two motors independently to move our robot would involve a lot of maths and be annoying and prone to error. Instead, we can use the DriveBase class to make driving our robot around a lot simpler.\nWe still need to initialize the motors:\n# Initialize the motors. left_motor = Motor(Port.B) right_motor = Motor(Port.C) But then we write this to create our DriveBase:\n# Initialize the drive base. robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) By specifying the dimensions of your robot, this class makes it easy to drive a given distance in millimeters or turn by a given number of degrees.\nPositive distances, radii, or drive speeds mean driving forward. Negative means backward.\nPositive angles and turn rates mean turning right. Negative means left. So when viewed from the top, positive means clockwise and negative means counterclockwise.\nParameters:\n left_motor, the motor that drives the left wheel. right_motor, the motor that drives the right wheel. wheel_diameter, diameter of the wheels in millimetres (mm). axle_track, distance between the points where both wheels touch the ground, in millimetres (mm).  Driving for a given distance or by an angle    Use the following commands to drive a given distance, or turn by a given angle. This is measured using the internal rotation sensors. Because wheels may slip while moving, the travelled distance and angle are only estimates.\nIf you initialized your robot using the line:\nrobot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) you will control it using:\nrobot.straight(300) robot.turn(-45) and so on. If instead you\u0026rsquo;d written:\nsuperchamp = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) you will control it using:\nsuperchamp.straight(300) superchamp.turn(-45) and so on.\n  straight(distance)    Drives straight for a given distance and then stops.\nParameters:\n distance, distance to travel in millimetres (mm).   turn(angle)    Turns in place by a given angle and then stops.\nParameters:\n angle, angle to turn in degrees (°).   curve(radius, angle)    Drives an arc along a circle of a given radius, by a given angle.\nParameters: radius (dimension: mm) – Radius of the circle. angle (angle: deg) – Angle along the circle.\nDrive forever    drive(drive_speed, turn_rate)    Starts driving at the specified speed and turn rate. Both values are measured at the center point between the wheels of the robot. It keeps going until you use stop() or change course by using drive() again. For example, you can drive until a sensor is triggered and then stop or turn around.\nParameters:\n drive_speed, speed of the robot in millimetres per second (mm/s). turn_rate, turn rate of the robot in degrees per second (°/s).   stop()    Stops the robot by letting the motors spin freely.\n## Example Movement Code  # Go forward and backwards for one metre. robot.straight(1000) robot.straight(-1000) # Set the drive base speed and turn rate. It keeps going until you use stop() robot.drive(100, 0) # Turn clockwise by 360 degrees and back again.  robot.turn(360) robot.turn(-360) # stop the motor robot.stop() # this stops any active movement and actively brakes the motor  # from pybricks.parameters import Port, Stop robot.stop(Stop.BRAKE) # this stops any active movement and leaves the motors on coast robot.stop(Stop.COAST) # Stops the motor and actively holds it at its current angle. Make sure you include Stop in  # from pybricks.parameters import Port, Stop robot.stop(Stop.HOLD) "},{"id":18,"href":"/dit8/gameDesign/03walkthroughs/shootingGame/","title":"Shooting game","parent":"Walk-throughs","content":"Shooting game\n"},{"id":19,"href":"/dit8/robotics/gettingStarted/touch/","title":"Touch Sensor","parent":"Getting Started","content":"adapted from PyBricks  Touch Sensor   A sensor lets an EV3 program measure and collect data about its surroundings. The Touch Sensor detects when its red button has been pressed or released.\nExample Code    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #!/usr/bin/env pybricks-micropython from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port, Stop from pybricks.robotics import DriveBase from pybricks.tools import wait from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor) # Initialize the EV3 Brick. ev3 = EV3Brick() # Initialize the motors. left_motor = Motor(Port.B) right_motor = Motor(Port.C) # Initialize the drive base. robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) # Initialize Touch Sensor touch_sensor = TouchSensor(Port.S1) # Drive forward until touch sensor is pressed robot.drive(1000, 0) while not touch_sensor.pressed(): wait(1) robot.stop()   "},{"id":20,"href":"/dit8/robotics/gettingStarted/ultrasonic/","title":"Ultrasonic Sensor","parent":"Getting Started","content":"adapted from PyBricks  Ultrasonic Sensor   The Ultrasonic Sensor is digital sensor that can measure the distance to an Object in front of it. It does this by sending out hight frequency sound waves and measuring how long it takes the sound to reflect back to the sensor. The sound frequency is too high for you to hear. Distance to an object is measured in millimeters (mm). This allows you to program your robot to stop at a certain distance from a wall.\nExample Code    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #!/usr/bin/env pybricks-micropython from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor, UltrasonicSensor from pybricks.parameters import Port from pybricks.tools import wait from pybricks.robotics import DriveBase # Initialize the EV3 Brick. ev3 = EV3Brick() # Initialize the Ultrasonic Sensor. It is used to detect # obstacles as the robot drives around. obstacle_sensor = UltrasonicSensor(Port.S4) # Initialize two motors with default settings on Port B and Port C. # These will be the left and right motors of the drive base. left_motor = Motor(Port.B) right_motor = Motor(Port.C) # The DriveBase is composed of two motors, with a wheel on each motor. # The wheel_diameter and axle_track values are used to make the motors # move at the correct speed when you give a motor command. # The axle track is the distance between the points where the wheels # touch the ground. robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) # Play a sound to tell us when we are ready to start moving ev3.speaker.beep() # The following loop makes the robot drive forward until it detects an # obstacle. Then it backs up and turns around. It keeps on doing this # until you stop the program. while True: # Begin driving forward at 200 millimeters per second. robot.drive(200, 0) # Wait until an obstacle is detected. This is done by repeatedly # doing nothing (waiting for 10 milliseconds) while the measured # distance is still greater than 300 mm. while obstacle_sensor.distance() \u0026gt; 300: wait(10) # Drive backward for 300 millimeters. robot.straight(-300) # Turn around by 120 degrees robot.turn(120)   "},{"id":21,"href":"/dit8/gameDesign/03walkthroughs/racingGame/","title":"Racing game","parent":"Walk-throughs","content":"Racing game\n"},{"id":22,"href":"/dit8/robotics/gettingStarted/color/","title":"Color Sensor","parent":"Getting Started","content":"adapted from PyBricks  Color Sensor   In almost all programming, American spellings are used. So as programmers we use colors, even though we would normally spell the word colours.  A sensor lets an EV3 program measure and collect data about is surroundings. The Color Sensor can detect color and reflected light.\nThree modes: Color, Reflected Light intensity and Ambient Light intensity.\n– Color Mode: Recognizes 7 colors (black, brown, blue, green, yellow, red, white) and No Color\n– Reflected Light: Measures the intensity of the light reflected back from a lamp that emits a red light. (0=very dark and 100=very light)\n– Ambient Light: Measures the strength of the light that enters the sensor from the environment. (0=very dark and 100=very light)\nExample Code    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #!/usr/bin/env pybricks-micropython from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port, Stop from pybricks.robotics import DriveBase from pybricks.tools import wait from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor) # Initialize the EV3 Brick. ev3 = EV3Brick() # Initialize the motors. left_motor = Motor(Port.B) right_motor = Motor(Port.C) # Initialize the drive base. robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104)   Here we initialize what sensors we would like by telling the EV3 what port it is plugged into and what we would like to call it when referring to it in our code. 18 19 20 21 22 23 24 25 26  # Initialize the sensors. line_sensor = ColorSensor(Port.S1) # Go forward while reflected light is less than 10. ev3.speaker.beep() robot.drive(100,0) while line_sensor.reflection() \u0026lt; 10: wait(10) robot.stop()  \n"},{"id":23,"href":"/dit8/robotics/gettingStarted/flowcharts/","title":"Flowcharts","parent":"Getting Started","content":"Flowcharts are a visual representation of program flow. A flowchart normally uses a combination of blocks and arrows to represent actions and sequence. Blocks typically represent actions. The order in which actions occur is shown using arrows that point from statement to statement. Sometimes a block will have multiple arrows coming out of it, representing a step where a decision must be made about which path to follow.\n Start and End symbols are represented as rounded rectangles, usually containing the word \u0026ldquo;Star\u0026rdquo; or \u0026ldquo;End\u0026rdquo;, but can be more specific such as \u0026ldquo;Power Robot Off\u0026rdquo; or \u0026ldquo;Stop All Motors\u0026rdquo;.\nActions are represented as rectangles and act as basic commands. Examples: wait(10) increment LineCount by 1 motors full ahead\nDecision blocks are represented as diamonds. These typically contain Yes/No questions. Decision blocks have two or more arrows coming Out Of them, representing the different paths that can be followed, depending on the outcome Of the decision. The arrows should always be labelled accordingly.\n  Example Flowchart    The following flowchart instructs a robot to run forward as long as its touch sensor is not pressed. When the touch sensor is pressed the motors stop and the program ends.    Example Flowchart    The following flowchart instructs a robot to run forward as long as its color sensor reflected light is less than 10%. When the color sensor reflected light is greater than 10% the robot will stop.    "},{"id":24,"href":"/dit8/robotics/gettingStarted/constructs/","title":"Programming Constructs","parent":"Getting Started","content":"Programs are designed using common building blocks. These building blocks, known as programming constructs (or programming concepts), form the basis for all programs.\nThere are three basic building blocks to consider:\n sequence is the order in which instructions occur and are processed selection determines which path a program takes when it is running iteration is the repeated execution of a section of code when a program is running    Sequence    Sequence is the order in which programming statements are executed. Programming statements usually run one after another in order, unless one of the other programming constructs is used. The sequence of a program is extremely important as once these are translated, carrying out instructions in the wrong order leads to a program performing incorrectly.\nThe following example code will execute each line in order/sequence\n1 2 3 4  print(\u0026#34;Let\u0026#39;s introduce ourselves.\u0026#34;) print(\u0026#34;My name is Eliza. What is your name?\u0026#34;) name = input() print(\u0026#34;Hello \u0026#34; + name + \u0026#34;, nice to meet you.\u0026#34;)  \r Sequence in a Flowchart     Sequence in a flowchart      Selection    IF statements    Selection is a programming construct where a section of code is run only if a condition is met. In programming, there are often occasions when a decision needs to be made. Selection is the process of making a decision. The result of the decision can either be TRUE or FALSE, this determines which path the program will take next.\nThe following code uses selection to test the condition varHeight \u0026gt; 1.6, if this condition is TRUE then \u0026ldquo;Tall enough to enter ride\u0026rdquo; is printed.\n1 2  if varHeight \u0026gt; 1.6: print(\u0026#34;Tall enough to enter ride\u0026#34;)  \rThe following code uses selection to test the condition username == \u0026ldquo;Callum\u0026rdquo;, if this condition is TRUE then \u0026ldquo;Access granted\u0026rdquo; is printed. If the condition is FASLE we can use else: to execute a different line of code.\n1 2 3 4  if username == \u0026#34;Callum\u0026#34;: print(\u0026#34;Access granted\u0026#34;) else: print(\u0026#34;Unknown username\u0026#34;)  \r Selection in a Flowchart    In flowcharts we us a diamond shape to represent a question or test condition that can be TRUE or FALSE.\n Selection in a flowchart      Iteration or Loop    Programs often need to repeat certain steps while or until a condition has been met. This process is known as iteration.\nIteration or repetition is often referred to as looping, since the program ‘loops’ back to an earlier line of code.\nIteration allows programmers to simplify a program and make it more efficient. Instead of writing out the same lines of code again and again(mistages happen), a programmer can write a section of code once, and ask the program to execute the same line repeatedly until no longer needed.\n"},{"id":25,"href":"/dit8/gameDesign/01gettingStarted/","title":"Getting started","parent":"Game Design","content":""},{"id":26,"href":"/dit8/gameDesign/02state/stateWhatIs/","title":"What is state?","parent":"State","content":"What is state?    Imagine you are enjoying a particularly engaging session of Uno with some friends, and by a peculiar set of circumstances you are required to pack up the game back into its pack, but you and your friends want to be able to resume exactly where you are when you next meet. What would you have to record so that you can restore the game exactly as it is right now?\nYou would need to note who is playing and which order they are sitting in, and also which cards they are holding. You\u0026rsquo;d also need to know whose turn it is and, because of the reverse cards, which direction you\u0026rsquo;re currently playing in.\nWould you need to jot down which cards are in the deck or the discard pile, and which order they are in? Why, or why not? What differece will it make?\nThis whole question of what is required to keep track of the game is called the game\u0026rsquo;s state. For some games, it is very little. Consider what you would have to record to pause, and later resume, a game of Noughts and Crosses. How about draughts, or chess? Could you pause a live-action game of soccer in mid play, and resume it later?\n"},{"id":27,"href":"/dit8/gameDesign/02state/stateReacting/","title":"Reacting to and changing state","parent":"State","content":"In all computer games, the game proceeds a teeny bit at a time, with each of the agents in the game making decisions about what to do next based on the current state, which then changes the game state, and then the agents all make a new set of decisions, and the game state changes again. From outside this can appear as a smooth, seamless and continuous process, but it is always made of little, discrete moves. You wouldn\u0026rsquo;t imagine that FIFA, or any of the other major sporting titles, was made by little steps of lumpy decision making, but it is, just many dozens of times per second.\nEven the user input looks discrete and lumpy to the computer, as it will look at the state of the inputs (your keyboard, mouse, controller) at the instant it needs to know what you wish to do. So while you might think of yourself as making a series of smooth-changing motions with the analog sticks, for example, the computer sees you making spot decisions about 60 times per second.\n"},{"id":28,"href":"/dit8/gameDesign/02state/","title":"State","parent":"Game Design","content":""},{"id":29,"href":"/dit8/gameDesign/03walkthroughs/verticalShooter/","title":"Vertical shooter","parent":"Walk-throughs","content":" Twin Bee  "},{"id":30,"href":"/dit8/gameDesign/02basics/","title":"Learning the basics","parent":"Game Design","content":""},{"id":31,"href":"/dit8/gameDesign/02state/stateProblems/","title":"Problems with state","parent":"State","content":"Keep it simple    Broadly speaking, the more state your program has, the more complex it is, and thus the more opportunities there are for mistakes. This should encourage us to look for a solution with as little state information as possible. As a simple example, in a fighting game, it is important to know whether a character is alive or dead, and how much health they have. So you might think to have an integer to keep track of health, and a couple of boolean flags to keep track of the character\u0026rsquo;s life status:\nhealth: int isAlive: bool isDead: bool But on inspection, you don\u0026rsquo;t need all this. First of all, a character in a game is usually either alive or dead, but not both or neither, so you could just have one of the boolean values, and look for isAlive or not isAlive. But actually, since you also have a health variable, it will likely work if you just check to see whether or not health \u0026gt; 0, and not need either of the boolean flags. It will depend on your specific project what things you can and can\u0026rsquo;t do, but this is a general thing to think about, as it is easy to over-complicate your project by accident, allowing bugs to creep in!\nWhat wrong looks like    If you\u0026rsquo;ve spent much time playing computer games, you\u0026rsquo;ve probably seen the side-effects of problems with a game\u0026rsquo;s state.\nIf you\u0026rsquo;ve ever played a first person shooter (FPS) or a role-playing game (RPG) and found yourself \u0026ldquo;stuck\u0026rdquo; in a wall, or a rock, or with your feet below the floor level, then you\u0026rsquo;ve entered a state that shouldn\u0026rsquo;t be possible.\nRPGs such as those from the Elder Scrolls, Mass Effect or Fallout series have a lot of state tied up in whether or not you\u0026rsquo;ve completed a certain mission, made a particular decision, or spoken to, saved or killed a certain character. So there are often dozens, even hundreds, of boolean flags keeping track of all this. Under these circumstances it is easy for the programmers to forget, when one checkpoint is cleared, to enable or disable one of the flags, which will lead to things like a subsequent mission not being available even though the previous one has been completed, or a character refusing to offer a conversation option, or being hostile when they shouldn\u0026rsquo;t, or a thousand other ways this could play out.\nMultiplayer challenges    Multiplayer games played on the one computer, such as split-screen console games, are not much more complicated than single player games; there are just more input devices to work through. Multi-system games, such as games played over LAN or the Internet, are much nastier to manage, however.\nIn a multi-system game, there is almost always a server, which manages the game, and then a series of clients, which are the player computers. The server can be either:\n a dedicated machine for running the game, which is the case for most games played over the internet, or one of the player computers, which \u0026ldquo;hosts\u0026rdquo; the game, and fulfils the role of the server as well as being a client for one of the players. This arrangement is more common for computers played over a local network.  Many games, such as Minecraft, can be set up in either way. In both cases it is the server which is in charge of maintaining and updating the state of the game, which it then distributes to the other machines. The more game state there is, the longer it will take to send to the other players. Large games will typically find ways to reduce the amount of game state that is required to be sent at a time, and minimise the people who need it.\nIn World of Warcraft, for example, breaking the world up into smaller regions means that a player in one area doesn\u0026rsquo;t need updates on anything happening in another area, so they need relatively little information, and there will be relatively few players in each region, compared with the world overall, so that information only needs to go to a few players. This is one of the reasons that game performance in the big cities of WoW can take a noticable dive: there are now far more people in the one place, meaning there is much more game state to distribute, and far more people to distribute it to, and handle moves from.\nIn an online game of something like chess or Uno, a delay of even several seconds between moves wouldn\u0026rsquo;t make any significant difference to the success of the game. Moves take quite a while anyway, a little transmission delay is no big thing. But in a first person shooter, delays in transmission cause big problems.\nIf an update hasn\u0026rsquo;t come from the server in time, the player computer can choose either to wait until it gets one, creating stutters and freezes in the game, or it can run the simulation locally with only the input it is getting, leading to other players running at walls or standing around awkwardly. The latter is usually better for dealing with small delays, as it keeps the game smooth for the player, and hopefully the game can get everything back on track before anything weird happens.\nThe longer the delay between state updates, the more likely the local copy of the state is to be wrong, and the greater the difference is likely to be. You can see the effects of this if, often after a brief stutter, either you or another player suddenly \u0026ldquo;teleports\u0026rdquo; to a slightly different location.\nFrom the server\u0026rsquo;s perspective, in a FPS it has a tight window to get the move data from the clients, update the game state, and distribute the new game state, if it wants to keep the game running smoothly. If an update doesn\u0026rsquo;t arrive from a client in time, rather than waiting indefinitely and causing a freeze, the server will probably assume there is no new information from the client and proceed. If it continues to have substantial problems repeatedly with the same client, a server sometimes is programmed to give up and \u0026ldquo;kick\u0026rdquo; the client from the game, in the hope that the game can continue to run smoothly for everyone else.\n"},{"id":32,"href":"/dit8/gameDesign/02state/updateDrawCycle/","title":"The update/draw cycle","parent":"State","content":"In Pygame Zero, as with most game engines, the code that manages the game state is separate from the code that handles the display. In Pygame Zero, there are two main functions:\n update(), which responds to inputs and manages the game state, and draw(), which coordinates updating the screen to match the game state.    stateDiagram-v2\rdirection LR\r[*] -- update()\rupdate() -- draw()\rdraw() -- update()\r Where possible, these two functions will be run, update then draw, update then draw, 60 times per second. Sometimes, however, the computer gets busy running another task in the background, or the code involved in drawing the screen takes longer than usual, and it isn\u0026rsquo;t possible to run draw() sixty times per second. If it only runs 58 times, or 51 times, it won\u0026rsquo;t make a particular difference, as anything faster than about 25 times per second will look smooth and continuous. The objects on the screen will still move smoothly, you just mightn\u0026rsquo;t get as many updates in a second as planned.\nBut humans are very good at anticipating timing, so if the game engine runs irregularly, it will affect the behaviour of moving objects, and the player will more likely notice. Consider what would happen if a person were to walk at a consistent pace from one side of the oval to the other, and you had your eyes closed, but opened them once every couple of seconds. You\u0026rsquo;ll quickly form an idea of their path in your mind, and will be able to accurately predict where they\u0026rsquo;ll be next time you open your eyes, whether you wait two seconds or four. So it is when the draw() function is run irregularly. But now imagine the person walking changes their speed, sometimes pacing faster, other times slower, perhaps pausing for just a fraction of a second here and there. You will now find it extremely hard to predict their motion, no matter how much of the time you have your eyes open. This is what it would be like if update() ran irregularly, and is much more disruptive to the user.\nYou can imagine, too, that if you were to design a simple multiplayer game, the server would be the one to update() the game state, but if it were a dedicated server it would have no screen to draw on. And each of the player computers would receive the game state from the server, and use it to draw() to their screens, but wouldn\u0026rsquo;t have to ever run the update function.\n"},{"id":33,"href":"/dit8/gameDesign/03walkthroughs/","title":"Walk-throughs","parent":"Game Design","content":""},{"id":34,"href":"/dit8/robotics/assessments/","title":"Assessment tasks","parent":"Robotics","content":""},{"id":35,"href":"/dit8/robotics/","title":"Robotics","parent":"8 DigiTech","content":""},{"id":36,"href":"/dit8/robotics/gettingStarted/baseCode/","title":"Starter code","parent":"Getting Started","content":"This is a good base to use at the top of each of your projects.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #!/usr/bin/env pybricks-micropython  from pybricks.hubs import EV3Brick from pybricks.ev3devices import Motor from pybricks.parameters import Port, Stop from pybricks.robotics import DriveBase from pybricks.tools import wait from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor, InfraredSensor, UltrasonicSensor, GyroSensor) # Initialize the EV3 Brick.  ev3 = EV3Brick() \u0026#34;\u0026#34;\u0026#34; Setting up motors and sensors ------------------ It is vital that you correctly tell the EV3 what sensors it will need and where they are connected. Any sensors listed below MUST be present on the listed ports. You can comment out one or more of these lines if you need to temporarily ignore a sensor. \u0026#34;\u0026#34;\u0026#34; # Initialize the motors.  left_motor = Motor(Port.B) right_motor = Motor(Port.C) # Initialize the sensors. touch_sensor = TouchSensor(Port.S1) color_sensor = ColorSensor(Port.S3) ultrasonic_sensor = UltrasonicSensor(Port.S4) # Initialize the drive base.  robot = DriveBase(left_motor, right_motor, wheel_diameter=55.5, axle_track=104) # ------------------------ # Write your program here. # ------------------------   "},{"id":37,"href":"/dit8/glossary/","title":"Glossary","parent":"8 DigiTech","content":""},{"id":38,"href":"/dit8/gameDesign/03walkthroughs/moreTutorials/","title":"More walk-throughs","parent":"Walk-throughs","content":"Simple Game Tutorials for Python and Pygame Zero 1.2\n"},{"id":39,"href":"/dit8/gameDesign/inspiration/","title":"Inspiration","parent":"Game Design","content":"Here is a selection of games which are over 30 years old, but which show that well thought out gameplay doesn\u0026rsquo;t need graphics to shine.\nMaybe one of these will inspire your next creation\u0026hellip;\n"},{"id":40,"href":"/dit8/troubleshooting/","title":"Troubleshooting","parent":"8 DigiTech","content":""},{"id":41,"href":"/dit8/reference/","title":"Reference materials","parent":"8 DigiTech","content":"Robotics     LEGO MicroPython Documentation LEGO Python for EV3 EV3 Tutorial  Game Design     Pygame Zero documentation Physics for Game Developers Teaching a kid to code with Pygame Zero  "},{"id":42,"href":"/dit8/teaching/","title":"Teaching materials","parent":"8 DigiTech","content":""},{"id":43,"href":"/dit8/gameDesign/02state/maintainingState/","title":"Maintaining State","parent":"State","content":""},{"id":44,"href":"/dit8/","title":"8 DigiTech","parent":"","content":"Welcome to Year 8 Digital Technologies!\nThis semester we will work on two broad topics:\n autonomous robots using LEGO Mindstorms EV3s game design using PyGame Zero   A LEGO Mindstorms EV3 robot   "},{"id":45,"href":"/dit8/glossary/argument/","title":"argument","parent":"Glossary","content":"When calling a function, the values given to it are called arguments. For example, in this case:\ntotal = add(3, 4) 3 and 4 are arguments to the function add().\nWhen defining a function, the pieces of information that the function takes to do its job are called parameters.\n"},{"id":46,"href":"/dit8/categories/","title":"Categories","parent":"8 DigiTech","content":""},{"id":47,"href":"/dit8/glossary/coordinate/","title":"co-ordinate system","parent":"Glossary","content":"In most programming environments (such as Pygame Zero), the screen co-ordinate system uses (x, y) co-ordinates, with the origin (0, 0) in the top left corner of the screen, with x to the right, and y going down.\nEverything to be displayed on the screen must be rastered, which means rendered into a grid of colored pixels.\n"},{"id":48,"href":"/dit8/glossary/color/","title":"color/colour","parent":"Glossary","content":"In almost all programming, American spellings are used. So as programmers we use colors, even though we would normally spell the word colours.\nFor most programming, colors are described by the amount of red, green, and blue light to emit. These numbers are normally in the range 0-255. In Pygame Zero, we list these as a tuple (red, green, blue), such as:\n(0, 150, 255) You can use the Google Color Picker to find different colors, and then copy the RGB value listed.\n"},{"id":49,"href":"/dit8/gameDesign/inspiration/EnchantedScepters/","title":"Enchanted Scepters","parent":"Inspiration","content":"by Silicon Beach Software (1984)\nIn this part-illustrated, part-text adventure, you are tasked with recovering four magical sceptres (earth, fire, wind and water, of course) to save your kingdom from invasion.\n "},{"id":50,"href":"/dit8/gameDesign/inspiration/Iago/","title":"Iago","parent":"Inspiration","content":"by David Reed (1984)\nIago was a very early Othello/Reversi game, which offered excellent gameplay. You could play against a friend or a computer with three levels of difficulty, on three different sizes of board.\nIt even has a special feature to hide the game if you are playing it at work and your boss is coming\u0026hellip;\n "},{"id":51,"href":"/dit8/glossary/parameter/","title":"parameter","parent":"Glossary","content":"When defining a function, the pieces of information that the function takes to do its job are called parameters. For example, here:\ndef add(first, second): return first + second first and second are the parameters of the function add().\nWhen calling a function, the values given to it are called arguments.\n"},{"id":52,"href":"/dit8/gameDesign/inspiration/PhraseCraze/","title":"Phrase Craze","parent":"Inspiration","content":"by Brad Pettit (1986)\nBorrowing heavily from the TV game show Wheel of Fortune, Phrase Craze offers up to four players the chance to relive the thrill of being on the set, complete with game board, wheel, and charming host. You could also modify the PhraseFile to create your own puzzles.\n "},{"id":53,"href":"/dit8/teaching/siteUrl/","title":"Site URL 🡄🡆","parent":"Teaching materials","content":"Learn about Pygame Zero here:\nhttps://tmcdigitech.github.io/dit8/\n"},{"id":54,"href":"/dit8/gameDesign/01gettingStarted/software/","title":"Software","parent":"Getting started","content":"To develop games using Pygame Zero, you have two main options:\n use Mu use another editor  Mu is set up to be very helpful for beginners. It has some keyboard shortcuts, good help text, nice shortcut buttons, and is generaly very friendly to use and has a lot of features to help beginners get started.\nAfter you have been writing code for a while, you may find that a standard Python environment and a \u0026ldquo;full\u0026rdquo; text editor like Visual Studio Code allows you a lot more power and flexibility, at the cost of doing some more basic things yourself.\nAn example of this is that Mu will automatically add the necessary first and last lines to your Pygame Zero file.\nThe very top line, line 1, must read:\nimport pgzrun And the very last line must read:\npgzrun.go() If you are using Mu, it will automatically add these lines if you forget. With VS Code or another editor, you will need to do this yourself.\nUsing Mu    Install Mu, using the Company Portal (on a school computer), or from the website. You\u0026rsquo;re done!\nThere is a beginner\u0026rsquo;s guide to Mu, if you want more help on how to use Mu.\nTo make games in Pygame Zero, make sure you select the mode Pygame Zero.\nUsing Visual Studio Code    From the Company Portal (on a school computer), or using the links below, install:\n Visual Studio Code Python  "},{"id":55,"href":"/dit8/gameDesign/01gettingStarted/fileStructure/","title":"Structuring your files","parent":"Getting started","content":"Each of your projects should live in its own folder somewhere sensible (like in a Digital Tech folder in your OneDrive!).\nDigital Tech/ │ ├── firstGame/ │ └── game.py │ ├── secondGame/ │ └── game.py │ ├── thirdGame/ │ └── game.py │ └── fourthGame/ └── game.py Within each of those folders, there will be python file with your game code in it, but there may well be other files and folders as well. Here is an example of a more complex project:\nmyGame/ ├── game.py │ ├── images/ │ ├── someImage.jpg │ ├── anotherImage.jpg │ └── ... # sprites, tiles and other image files │ ├── fonts/ │ └── ... # any font files │ ├── sounds/ │ └── ... # any sound files │ └── music/ └── ... # any music files You don\u0026rsquo;t need to have those folders unless you have something to put in them.\nCheck your version of Mu\nIf you are using a version of Mu older than 1.1.0-alpha.2, the shortcut buttons in Pygame Zero mode (Images, Sounds, Fonts and Music) will open folders in Mu\u0026rsquo;s default save location. If you have saved your project in a different location (like your OneDrive) you won\u0026rsquo;t be able to use these shortcut buttons, as they won\u0026rsquo;t open the right folders.\nFrom 1.1.0-alpha.2 onwards, the buttons will open folders relative to the file you have open, so they will always work, regardless of where you save your game file.\n "},{"id":56,"href":"/dit8/gameDesign/inspiration/StuntCopter/","title":"StuntCopter","parent":"Inspiration","content":"by Duane Blehm (1986)\nPart of the genius of this game is how simple it is. Your aim is to drop people out of a helicopter onto the cart, carefully avoiding the rider and the horse. The further up you drop from, the more points you get. See what happens when you drop someone through the clouds\u0026hellip;\nIf you go to Options \u0026gt; OffScreen in the menu, you can also see the complete sprite sheet for the game; a nice touch.\n "},{"id":57,"href":"/dit8/tags/","title":"Tags","parent":"8 DigiTech","content":""},{"id":58,"href":"/dit8/glossary/tuple/","title":"tuple","parent":"Glossary","content":"A tuple is a single unit of data made up of multiple values. In Python they are defined using round brackets, with commas separating the values. Tuples can contain all sorts of data as values, but in Pygame Zero we use them most often for colors (red, green, blue) and co-ordinates (x, y).\n"},{"id":59,"href":"/dit8/troubleshooting/01whybroken/","title":"Why won't my program work?","parent":"Troubleshooting","content":"Here is a checklist of things to look for if something is wrong\u0026hellip;\nSpelling and Capitalisation    Remember that the computer is really, really, really, really stupid. It will recognise only words it has been taught; it is not clever enough to handle spelling mistakes - these will confuse it. It is also not clever enough to know that most of the time we use A and a interchangeably, so you have to make sure that if the computer is expecting a capital letter, you give it one, and vice versa.\n"}]